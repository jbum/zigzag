#!/usr/bin/env python3
"""
Generate puzzles with multiple solutions by removing one clue from minimized puzzles.

This script reads puzzles from a _BF (brute-force minimized) file where each puzzle
has the minimum number of clues for a unique solution. By removing a single clue,
we create puzzles that (theoretically) have multiple solutions. These are useful
for testing the BF solver's ability to detect multiple solutions.

Usage:
    python make_mult_puzzles.py <input_file>

Example:
    python make_mult_puzzles.py puzzledata/puzzles_10x10_BF.txt

This produces puzzledata/puzzles_10x10_BF_mults.txt
"""

import argparse
import os
import sys


def decode_givens(givens_string):
    """
    Decode RLE-encoded givens string.

    Lowercase letters represent runs of unlabeled vertices (a=1, b=2, ..., z=26).
    Digits 0-4 represent clues.

    Returns list of clue values (int 0-4 or None for unlabeled).
    """
    result = []
    for char in givens_string:
        if char.isdigit():
            result.append(int(char))
        elif char.islower():
            run_length = ord(char) - ord('a') + 1
            result.extend([None] * run_length)
    return result


def encode_givens(clues):
    """
    Encode a list of clue values to RLE string.

    Args:
        clues: List of int (0-4) or None for unlabeled vertices

    Returns:
        RLE-encoded string
    """
    result = []
    unlabeled_count = 0

    for clue in clues:
        if clue is None:
            unlabeled_count += 1
        else:
            # Flush unlabeled run first
            while unlabeled_count > 0:
                run = min(unlabeled_count, 26)
                result.append(chr(ord('a') + run - 1))
                unlabeled_count -= run
            result.append(str(clue))

    # Flush remaining unlabeled
    while unlabeled_count > 0:
        run = min(unlabeled_count, 26)
        result.append(chr(ord('a') + run - 1))
        unlabeled_count -= run

    return ''.join(result)


def parse_puzzle_line(line):
    """
    Parse a puzzle line from a testsuite file.

    Returns dict with: name, width, height, givens, answer, comment
    Or None if line should be ignored.
    """
    line = line.strip()
    if not line or line.startswith('#') or line.startswith(';'):
        return None

    parts = line.split('\t')
    if len(parts) < 4:
        return None

    result = {
        'name': parts[0],
        'width': int(parts[1]),
        'height': int(parts[2]),
        'givens': parts[3],
        'answer': parts[4] if len(parts) > 4 else '',
        'comment': parts[5] if len(parts) > 5 else ''
    }

    return result


def remove_one_clue(givens_string):
    """
    Remove the first non-None clue from the givens and return the new givens string.

    Returns the modified givens string with one clue removed (made unlabeled).
    """
    clues = decode_givens(givens_string)

    # Find and remove the first clue
    for i, clue in enumerate(clues):
        if clue is not None:
            clues[i] = None
            break

    return encode_givens(clues)


def main():
    parser = argparse.ArgumentParser(
        description='Generate puzzles with multiple solutions by removing one clue'
    )
    parser.add_argument('input_file', help='Path to input puzzle file (should be a _BF file)')

    args = parser.parse_args()

    # Generate output filename by inserting _mults before .txt
    input_base, input_ext = os.path.splitext(args.input_file)
    output_file = f"{input_base}_mults{input_ext}"

    # Read input puzzles and header comments
    header_lines = []
    puzzles = []

    with open(args.input_file, 'r') as f:
        for line in f:
            stripped = line.strip()
            if stripped.startswith('#') or stripped.startswith(';'):
                header_lines.append(line)
            else:
                puzzle = parse_puzzle_line(line)
                if puzzle:
                    puzzles.append(puzzle)

    if not puzzles:
        print(f"No puzzles found in {args.input_file}", file=sys.stderr)
        sys.exit(1)

    # Generate output
    with open(output_file, 'w') as f:
        # Write new header
        f.write(f"# Multi-solution puzzles derived from {os.path.basename(args.input_file)}\n")
        f.write(f"# Generated by: make_mult_puzzles.py {args.input_file}\n")
        f.write(f"# Each puzzle has one clue removed from the minimized puzzle.\n")
        f.write(f"# These puzzles are expected to have multiple solutions.\n")
        f.write(f"# Count: {len(puzzles)}\n")
        f.write(f"#\n")

        # Preserve some original header info
        for line in header_lines:
            if 'Size:' in line or 'Solver:' in line:
                f.write(line)

        f.write("\n")

        # Write modified puzzles
        for puzzle in puzzles:
            new_givens = remove_one_clue(puzzle['givens'])

            # Count original clues
            orig_clues = decode_givens(puzzle['givens'])
            orig_count = sum(1 for c in orig_clues if c is not None)

            # New name with _mult suffix
            new_name = puzzle['name'] + "_mult"

            # Write the puzzle line with blank answer
            f.write(f"{new_name}\t{puzzle['width']}\t{puzzle['height']}\t{new_givens}\t\t# orig_givens={orig_count-1}\n")

    print(f"Created {output_file} with {len(puzzles)} puzzles")
    print(f"Each puzzle has one clue removed from the original.")


if __name__ == '__main__':
    main()
